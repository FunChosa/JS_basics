

/*
В первой строке появляется setTimeout, который ставит переданный колбэк в очередь макрозадач (macrotask queue) на выполнение.
в переменную promise запишется промис и создание промиса происходит синхронно,поэтому код и callback выполнится незамедлтельно.
Далее мы уведомляем потребителя then, что хотели бы выполнить переданную функцию после успешного выполнения промиса.
Так как промис уже имеет состояние fulfilled (мы вызвали resolve() при его создании), 
колбэк из then будет немедленно передан в очередь микрозадач (microtask queue) на выполнение.

В конце выполнения скрипта выведется 'End'.

Основные задачи закончились и теперь опустошается очередь микрозадач. 
В ней находится только ранее переданный в then колбэк. 
В результате его выполнения в консоль выведется 'Promise resolve'.

Так как очередь микрозадач опустела, можно продолжить выполнять код из очереди макрозадач. 
Там сейчас находится только колбэк, который мы передавали setTimeout. После его выполнения выведется 'setTimeout'.
таким образом результат будет следующий:

Promise
End
Promise resolve
setTimeout
*/

setTimeout(() => {
    console.log('setTimeout'); // 4. Callback queue -> Call Stack 
  }, 0);
  const promise = new Promise((resolve) => { 
    console.log('Promise');// 1. Call Stack 
    resolve();
  });
  promise.then(() => {
    console.log('Promise resolve'); //3. Microtask queue -> Call Stack 
  });
  console.log('End'); // 2. Call Stack 